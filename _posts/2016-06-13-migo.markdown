---
layout: project
title: "Scaling Django to build an awesome search engine"
date:   2016-05-29
categories: projects
summary: "Built a search engine that lets you search for philanthropy events near you."
link: ""
---
Migo is a search engine that lets you find philanthropy events near you

### Source
* [Github code](https://github.com/minupalaniappan/migo)

### How it got started

Migo was a hack I wrote for Bronco Hack, the official Santa Clara University Hackathon. At the time of the hackathon, I was playing around with Django and wanted to implement the framework in a 24 hour period. This hackathon was the perfect time play around with it.

### The development proccess

* Routing
Django, like most python frameworks, allows you to route your params to a function. In Django, GET params are routed like so...

```python
url(r'^search/(?P<searchterm>[\w|\W]+)/1/(?P<page>\w+)/', 'migoapp.views.spec'),
url(r'^search/(?P<searchterm>[\w|\W]+)/(?P<startyear>\w+)-
(?P<startmonth>\w+)-(?P<startday>\w+)/(?P<endyear>\w+)-
(?P<endmonth>\w+)-(?P<endday>\w+)/2/(?P<page>\w+)/',
'migoapp.views.spec2'),
```

These are two different routes; one takes ```searchterm``` and fetches the specific ```page``` in the list of results.
The nex route is a little more specific; this time, it takes ```startday```, ```startyear```, 	```startmonth``` and the respect end variables.


* API Calls

```python
def spec2(request, searchterm, startyear, startmonth,
startday, endyear, endmonth, endday, page):
	city = str(searchterm)
  	tempurl = 'http://127.0.0.1:8000/search/' + searchterm + '/'
  	str = 'https://www.eventbriteapi.com/v3/events/search/?'
  	str += 'token=4FDXOHJM6UTWIHWH76TA&format=json&q=volunteer&venue.city='
  	response = urllib.urlopen('' + city + '&start_date.range_start='
  	+ startyear + '-' + startmonth + '-' + startday + 'T00:00:00Z'
  	+ '&start_date.range_end=' + endyear + '-'
  	+ endmonth + '-' + endday + 'T00:00:00Z' + '&page=' + page);
  	data = json.loads(response.read())
```

Once these functions were properly routed, we would like to call the proper APIs. As you can see, our data source of choice was Eventbrite. So once the url was built with the parameters passed into ```spec2```, we would convert the returned output to JSON. At this point, handling the JSON with Jinja on the front-end was simple.

* Front-end

There were only two templates used for this project. The search page included a big input field similar to what you would see on Google's homepage. The results page is where there was significant thought put into design. Providing visuals on that page was important to me, so I decided to implement Google Maps to provide more relatibility for the user.

```javascript
<script type="text/javascript">
function initialize() {
    var mapCanvas = document.getElementById('map');
    var mapOptions = {
      center: new google.maps.LatLng("{{ events.0.lat }}","{{ events.0.lon }}"),
      zoom: 3,
      mapTypeId: google.maps.MapTypeId.ROADMAP
    }
    var map = new google.maps.Map(mapCanvas, mapOptions)
}
google.maps.event.addDomListener(window, 'load', initialize);
</script>
```

I fetched the latitude and longitude from the evenbrite data and injected it into a JS object. Thats what ```events.0.lat``` and ```events.0.lon``` are in this case.

* In Competition

Migo worked fairly well, although applying some sort of Cache via Redis could have really made the technology more impressive. Broncohack had some great projects, so beating out competition proved to be tough.

Thanks for reading!