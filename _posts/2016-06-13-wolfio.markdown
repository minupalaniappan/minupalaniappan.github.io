---
layout: project
title: "Adapting Twilio and Wolfram Alpha to produce a robust solving solution"
date:   2016-05-29
categories: projects
summary: "I built an SMS tool that responds to math-based texts; it solves the question and responds on any phone."
link: ""
---
Wolfio is an SMS tool that allows you to solve any mathematics-based question.

### Source
* [Github code](https://github.com/minupalaniappan/Wolfio)
* [Devpost](http://devpost.com/software/wolfio)

### How did the project start?
Well, the idea for Wolfio was concieved at HackingEDU: a 36 hour programming competition in the heart of San Mateo, CA. I had just wrapped up my last quarter of math; it was on linear algebra so naturally I evolved into a Wolfram Alpha power-user during that time.

I loved Wolfram, so I thought about ways of extending its powerful symbolic interpreter. I realized that the best way to extend the technology was through MMS and SMS; after all, all mobile devices have the ability to send and view MMS/SMS messages.

I told my friend Matt about the idea, and he was ready to tackle it with me at HackingEDU.

### The development proccess

The technology stack was fairly simple. I whipped up a Flask project that came standard with routing. I then integrated Twilio's Python service so that it could interact with Flask GET params. This is how we were going to fetch inputs and serve the output (solution).

All inputs would be recieved at the root route like so...

```python
@app.route("/", methods=['GET', 'POST'])
def main():
	from_number = request.values.get('From', None)
	body = request.values.get('Body', None)
	resp = twilio.twiml.Response()
	resp.message("Answer: " + retrieveTokens(str(body)))
	return str(resp)
```

We fetch the content, which in this case is ```body ```. We then bundle it in the Twilio ```response``` and throw it in `retrieveTokens()`. This function was the blackbox that would essentially tokenize the query and send it over to custom written Wolfram APIs.

The string manipulation was fairly intensive. Just think about it; we are building a calculator that doesn't just solve basic addition and subtraction. We are building a comprehensive tool that solves multivariable calculus and complex alegbra. Developing an intuitive notation for users proved to be a tremendous challenge.

The string manipulation was half the battle; the other half of this fight was in building the Wolfram APIs. Matt seemed to pick up their Wolfram's function builder pretty quickly, so our teamwork really kicked in halfway through the hackathon.

So, lets assume that we now have all the tokens neccesary to solve a math problem. We now need to route these tokens to the right Wolfram API.


```python
{
	'functionName': 'DERfunction',
	'parameterNames': ['q', 'withRespect', 'nth']
}
```
Here, given these three tokens, we route it to the ```'DERfunction'``` in our bank of Wolfram APIs. It is done like so...

```python
def executeMethod(function, parameters):
	baseURL = '...'
	i = 0
	while function != functions[i]['functionName']: i += 1
	URLsuffix = functions[i]['functionName'] + '?q='
	URLsuffix += urllib.quote_plus(parameters[0])

	for pname, pvalue in zip(functions[i]['parameterNames'][1:], parameters[1:]):
		URLsuffix += '&' + urllib.quote_plus(pname)
		URLsuffix += '=' + urllib.quote_plus(pvalue)
	answer = urllib2.urlopen(baseURL + URLsuffix)
	for line in answer:
		return line
```

```URLsuffix``` is our concanetated GET string that is then manipulated by the specific Wolfram function. We then fetch the URL repsonses using ```urllib2.urlopen``` and iterate the given output in a pretty print.

### Results
The application worked like a charm and it what was even more impressive was that it was compatible with standard flip phones. We want to optimize this tool so that it can interpret more queries and answer more complex questions. Below are images of the hack working on Matt's flip phone.

![img]({{ site.url }}/assets/wolfio/wolfio1.jpg)
![img]({{ site.url }}/assets/wolfio/wolfio2.jpg)

Thanks for reading.


